// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        (unknown)
// source: ar/v1/events.proto

package arv1

import (
	_ "buf.build/gen/go/bufbuild/protovalidate/protocolbuffers/go/buf/validate"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Commands are intents, i.e. "please do this". Example: Start/STOP from UI -> Robot driver
type CommandType int32

const (
	CommandType_COMMAND_TYPE_UNSPECIFIED CommandType = 0
	// Workflow/UI intent
	CommandType_COMMAND_TYPE_TASK_COMPLETE  CommandType = 10
	CommandType_COMMAND_TYPE_TASK_ASSIGN    CommandType = 11
	CommandType_COMMAND_TYPE_TASK_UNDO      CommandType = 12
	CommandType_COMMAND_TYPE_TASK_HIGHLIGHT CommandType = 13
	CommandType_COMMAND_TYPE_TASK_HELP      CommandType = 14
	// Robot control intent
	CommandType_COMMAND_TYPE_ROBOT_START_STOP          CommandType = 100
	CommandType_COMMAND_TYPE_ROBOT_TOGGLE_FREE_DRIVE   CommandType = 101
	CommandType_COMMAND_TYPE_ROBOT_START_COLLABORATION CommandType = 102
	CommandType_COMMAND_TYPE_ROBOT_STOP_COLLABORATION  CommandType = 103
	CommandType_COMMAND_TYPE_ROBOT_ACKNOWLEDGE         CommandType = 104
)

// Enum value maps for CommandType.
var (
	CommandType_name = map[int32]string{
		0:   "COMMAND_TYPE_UNSPECIFIED",
		10:  "COMMAND_TYPE_TASK_COMPLETE",
		11:  "COMMAND_TYPE_TASK_ASSIGN",
		12:  "COMMAND_TYPE_TASK_UNDO",
		13:  "COMMAND_TYPE_TASK_HIGHLIGHT",
		14:  "COMMAND_TYPE_TASK_HELP",
		100: "COMMAND_TYPE_ROBOT_START_STOP",
		101: "COMMAND_TYPE_ROBOT_TOGGLE_FREE_DRIVE",
		102: "COMMAND_TYPE_ROBOT_START_COLLABORATION",
		103: "COMMAND_TYPE_ROBOT_STOP_COLLABORATION",
		104: "COMMAND_TYPE_ROBOT_ACKNOWLEDGE",
	}
	CommandType_value = map[string]int32{
		"COMMAND_TYPE_UNSPECIFIED":               0,
		"COMMAND_TYPE_TASK_COMPLETE":             10,
		"COMMAND_TYPE_TASK_ASSIGN":               11,
		"COMMAND_TYPE_TASK_UNDO":                 12,
		"COMMAND_TYPE_TASK_HIGHLIGHT":            13,
		"COMMAND_TYPE_TASK_HELP":                 14,
		"COMMAND_TYPE_ROBOT_START_STOP":          100,
		"COMMAND_TYPE_ROBOT_TOGGLE_FREE_DRIVE":   101,
		"COMMAND_TYPE_ROBOT_START_COLLABORATION": 102,
		"COMMAND_TYPE_ROBOT_STOP_COLLABORATION":  103,
		"COMMAND_TYPE_ROBOT_ACKNOWLEDGE":         104,
	}
)

func (x CommandType) Enum() *CommandType {
	p := new(CommandType)
	*p = x
	return p
}

func (x CommandType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CommandType) Descriptor() protoreflect.EnumDescriptor {
	return file_ar_v1_events_proto_enumTypes[0].Descriptor()
}

func (CommandType) Type() protoreflect.EnumType {
	return &file_ar_v1_events_proto_enumTypes[0]
}

func (x CommandType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CommandType.Descriptor instead.
func (CommandType) EnumDescriptor() ([]byte, []int) {
	return file_ar_v1_events_proto_rawDescGZIP(), []int{0}
}

// EventType: events are facts, i.e. "this just happened".
//
// It is intended for low-frequency events. One example could be WAYPOINT_REACHED contrary to TELEMETRY_ROBOT_TCP
// Events must be grounded in actual events and not just because "a prediction said so".
type EventType int32

const (
	EventType_EVENT_TYPE_UNSPECIFIED EventType = 0
	// Workflow facts
	EventType_EVENT_TYPE_PROCESS_COMPLETE              EventType = 10
	EventType_EVENT_TYPE_SEQUENCE_COMPLETE             EventType = 11
	EventType_EVENT_TYPE_TASK_COMPLETE                 EventType = 12
	EventType_EVENT_TYPE_ROBOT_WAYPOINT_REACHED        EventType = 100
	EventType_EVENT_TYPE_ROBOT_PLAN_STARTED            EventType = 130
	EventType_EVENT_TYPE_ROBOT_PLAN_CHANGED            EventType = 131
	EventType_EVENT_TYPE_ROBOT_PLAN_ABORTED            EventType = 132
	EventType_EVENT_TYPE_ROBOT_PLAN_COMPLETED          EventType = 133
	EventType_EVENT_TYPE_ROBOT_WAITING_FOR_ACKNOWLEDGE EventType = 150
	EventType_EVENT_TYPE_ROBOT_WAITING_FOR_HELP        EventType = 151
	EventType_EVENT_TYPE_ROBOT_WAITING_TASK_RELEASE    EventType = 152
)

// Enum value maps for EventType.
var (
	EventType_name = map[int32]string{
		0:   "EVENT_TYPE_UNSPECIFIED",
		10:  "EVENT_TYPE_PROCESS_COMPLETE",
		11:  "EVENT_TYPE_SEQUENCE_COMPLETE",
		12:  "EVENT_TYPE_TASK_COMPLETE",
		100: "EVENT_TYPE_ROBOT_WAYPOINT_REACHED",
		130: "EVENT_TYPE_ROBOT_PLAN_STARTED",
		131: "EVENT_TYPE_ROBOT_PLAN_CHANGED",
		132: "EVENT_TYPE_ROBOT_PLAN_ABORTED",
		133: "EVENT_TYPE_ROBOT_PLAN_COMPLETED",
		150: "EVENT_TYPE_ROBOT_WAITING_FOR_ACKNOWLEDGE",
		151: "EVENT_TYPE_ROBOT_WAITING_FOR_HELP",
		152: "EVENT_TYPE_ROBOT_WAITING_TASK_RELEASE",
	}
	EventType_value = map[string]int32{
		"EVENT_TYPE_UNSPECIFIED":                   0,
		"EVENT_TYPE_PROCESS_COMPLETE":              10,
		"EVENT_TYPE_SEQUENCE_COMPLETE":             11,
		"EVENT_TYPE_TASK_COMPLETE":                 12,
		"EVENT_TYPE_ROBOT_WAYPOINT_REACHED":        100,
		"EVENT_TYPE_ROBOT_PLAN_STARTED":            130,
		"EVENT_TYPE_ROBOT_PLAN_CHANGED":            131,
		"EVENT_TYPE_ROBOT_PLAN_ABORTED":            132,
		"EVENT_TYPE_ROBOT_PLAN_COMPLETED":          133,
		"EVENT_TYPE_ROBOT_WAITING_FOR_ACKNOWLEDGE": 150,
		"EVENT_TYPE_ROBOT_WAITING_FOR_HELP":        151,
		"EVENT_TYPE_ROBOT_WAITING_TASK_RELEASE":    152,
	}
)

func (x EventType) Enum() *EventType {
	p := new(EventType)
	*p = x
	return p
}

func (x EventType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (EventType) Descriptor() protoreflect.EnumDescriptor {
	return file_ar_v1_events_proto_enumTypes[1].Descriptor()
}

func (EventType) Type() protoreflect.EnumType {
	return &file_ar_v1_events_proto_enumTypes[1]
}

func (x EventType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use EventType.Descriptor instead.
func (EventType) EnumDescriptor() ([]byte, []int) {
	return file_ar_v1_events_proto_rawDescGZIP(), []int{1}
}

// TelemetryType: telemetry is current state, i.e. "here is my state"
// It is expected to be high-frequency updates or at least updates every time the state have changed
type TelemetryType int32

const (
	TelemetryType_TELEMETRY_TYPE_UNSPECIFIED        TelemetryType = 0
	TelemetryType_TELEMETRY_TYPE_ROBOT_TCP          TelemetryType = 100 // Current TCP for the robot
	TelemetryType_TELEMETRY_TYPE_ROBOT_JOINT_ANGLES TelemetryType = 101 // Current joint angles for the robot
	TelemetryType_TELEMETRY_TYPE_ROBOT_FORCE_TORQUE TelemetryType = 102 // Current measured force/torque values
	TelemetryType_TELEMETRY_TYPE_ROBOT_STATE        TelemetryType = 110 // Current robot state. Check robot.v1.robot_state.proto for actual values.
)

// Enum value maps for TelemetryType.
var (
	TelemetryType_name = map[int32]string{
		0:   "TELEMETRY_TYPE_UNSPECIFIED",
		100: "TELEMETRY_TYPE_ROBOT_TCP",
		101: "TELEMETRY_TYPE_ROBOT_JOINT_ANGLES",
		102: "TELEMETRY_TYPE_ROBOT_FORCE_TORQUE",
		110: "TELEMETRY_TYPE_ROBOT_STATE",
	}
	TelemetryType_value = map[string]int32{
		"TELEMETRY_TYPE_UNSPECIFIED":        0,
		"TELEMETRY_TYPE_ROBOT_TCP":          100,
		"TELEMETRY_TYPE_ROBOT_JOINT_ANGLES": 101,
		"TELEMETRY_TYPE_ROBOT_FORCE_TORQUE": 102,
		"TELEMETRY_TYPE_ROBOT_STATE":        110,
	}
)

func (x TelemetryType) Enum() *TelemetryType {
	p := new(TelemetryType)
	*p = x
	return p
}

func (x TelemetryType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TelemetryType) Descriptor() protoreflect.EnumDescriptor {
	return file_ar_v1_events_proto_enumTypes[2].Descriptor()
}

func (TelemetryType) Type() protoreflect.EnumType {
	return &file_ar_v1_events_proto_enumTypes[2]
}

func (x TelemetryType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TelemetryType.Descriptor instead.
func (TelemetryType) EnumDescriptor() ([]byte, []int) {
	return file_ar_v1_events_proto_rawDescGZIP(), []int{2}
}

// Plan is planned (or expected) future state.
type PlanType int32

const (
	PlanType_PLAN_TYPE_UNSPECIFIED                PlanType = 0
	PlanType_PLAN_TYPE_ROBOT_PATH                 PlanType = 100 // Planned path for the robot's next action(s)
	PlanType_PLAN_TYPE_ROBOT_JOINT_ANGLES         PlanType = 101 // Planned joint angles for the robot's next action(s)
	PlanType_PLAN_TYPE_ROBOT_WAYPOINTS            PlanType = 102 // Planned waypoints for the robot's next action(s)
	PlanType_PLAN_TYPE_ROBOT_ESTIMATED_COMPLETION PlanType = 123
	PlanType_PLAN_TYPE_ROBOT_TASK_SEQUENCE        PlanType = 124
	PlanType_PLAN_TYPE_TASK_SEQUENCE              PlanType = 200
)

// Enum value maps for PlanType.
var (
	PlanType_name = map[int32]string{
		0:   "PLAN_TYPE_UNSPECIFIED",
		100: "PLAN_TYPE_ROBOT_PATH",
		101: "PLAN_TYPE_ROBOT_JOINT_ANGLES",
		102: "PLAN_TYPE_ROBOT_WAYPOINTS",
		123: "PLAN_TYPE_ROBOT_ESTIMATED_COMPLETION",
		124: "PLAN_TYPE_ROBOT_TASK_SEQUENCE",
		200: "PLAN_TYPE_TASK_SEQUENCE",
	}
	PlanType_value = map[string]int32{
		"PLAN_TYPE_UNSPECIFIED":                0,
		"PLAN_TYPE_ROBOT_PATH":                 100,
		"PLAN_TYPE_ROBOT_JOINT_ANGLES":         101,
		"PLAN_TYPE_ROBOT_WAYPOINTS":            102,
		"PLAN_TYPE_ROBOT_ESTIMATED_COMPLETION": 123,
		"PLAN_TYPE_ROBOT_TASK_SEQUENCE":        124,
		"PLAN_TYPE_TASK_SEQUENCE":              200,
	}
)

func (x PlanType) Enum() *PlanType {
	p := new(PlanType)
	*p = x
	return p
}

func (x PlanType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PlanType) Descriptor() protoreflect.EnumDescriptor {
	return file_ar_v1_events_proto_enumTypes[3].Descriptor()
}

func (PlanType) Type() protoreflect.EnumType {
	return &file_ar_v1_events_proto_enumTypes[3]
}

func (x PlanType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PlanType.Descriptor instead.
func (PlanType) EnumDescriptor() ([]byte, []int) {
	return file_ar_v1_events_proto_rawDescGZIP(), []int{3}
}

type HandlerCardinality int32

const (
	HandlerCardinality_HANDLER_CARDINALITY_UNSPECIFIED  HandlerCardinality = 0
	HandlerCardinality_HANDLER_CARDINALITY_AT_LEAST_ONE HandlerCardinality = 1
	HandlerCardinality_HANDLER_CARDINALITY_EXACTLY_ONE  HandlerCardinality = 2
	HandlerCardinality_HANDLER_CARDINALITY_AT_MOST_ONE  HandlerCardinality = 3
)

// Enum value maps for HandlerCardinality.
var (
	HandlerCardinality_name = map[int32]string{
		0: "HANDLER_CARDINALITY_UNSPECIFIED",
		1: "HANDLER_CARDINALITY_AT_LEAST_ONE",
		2: "HANDLER_CARDINALITY_EXACTLY_ONE",
		3: "HANDLER_CARDINALITY_AT_MOST_ONE",
	}
	HandlerCardinality_value = map[string]int32{
		"HANDLER_CARDINALITY_UNSPECIFIED":  0,
		"HANDLER_CARDINALITY_AT_LEAST_ONE": 1,
		"HANDLER_CARDINALITY_EXACTLY_ONE":  2,
		"HANDLER_CARDINALITY_AT_MOST_ONE":  3,
	}
)

func (x HandlerCardinality) Enum() *HandlerCardinality {
	p := new(HandlerCardinality)
	*p = x
	return p
}

func (x HandlerCardinality) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (HandlerCardinality) Descriptor() protoreflect.EnumDescriptor {
	return file_ar_v1_events_proto_enumTypes[4].Descriptor()
}

func (HandlerCardinality) Type() protoreflect.EnumType {
	return &file_ar_v1_events_proto_enumTypes[4]
}

func (x HandlerCardinality) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use HandlerCardinality.Descriptor instead.
func (HandlerCardinality) EnumDescriptor() ([]byte, []int) {
	return file_ar_v1_events_proto_rawDescGZIP(), []int{4}
}

// ExchangeType represent a single 'event' or exchange.
//
// Example: robot motion
// 1) UI produces: { Command: ROBOT_START_STOP }
// 2) Planner produces: { Plan: ROBOT_PATH }
// 3) Driver publishes: { Telemetry: ROBOT_TCP }
// 4) System emits: { Event: ROBOT_STARTED_TASK }
type ExchangeType struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Command       CommandType            `protobuf:"varint,1,opt,name=command,proto3,enum=ar.v1.CommandType" json:"command,omitempty"`       // Requested intent (future)
	Event         EventType              `protobuf:"varint,2,opt,name=event,proto3,enum=ar.v1.EventType" json:"event,omitempty"`             // Confirmed fact (past)
	Telemetry     TelemetryType          `protobuf:"varint,3,opt,name=telemetry,proto3,enum=ar.v1.TelemetryType" json:"telemetry,omitempty"` // Observed state (now)
	Plan          PlanType               `protobuf:"varint,4,opt,name=plan,proto3,enum=ar.v1.PlanType" json:"plan,omitempty"`                // Planned intent (future)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExchangeType) Reset() {
	*x = ExchangeType{}
	mi := &file_ar_v1_events_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExchangeType) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExchangeType) ProtoMessage() {}

func (x *ExchangeType) ProtoReflect() protoreflect.Message {
	mi := &file_ar_v1_events_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExchangeType.ProtoReflect.Descriptor instead.
func (*ExchangeType) Descriptor() ([]byte, []int) {
	return file_ar_v1_events_proto_rawDescGZIP(), []int{0}
}

func (x *ExchangeType) GetCommand() CommandType {
	if x != nil {
		return x.Command
	}
	return CommandType_COMMAND_TYPE_UNSPECIFIED
}

func (x *ExchangeType) GetEvent() EventType {
	if x != nil {
		return x.Event
	}
	return EventType_EVENT_TYPE_UNSPECIFIED
}

func (x *ExchangeType) GetTelemetry() TelemetryType {
	if x != nil {
		return x.Telemetry
	}
	return TelemetryType_TELEMETRY_TYPE_UNSPECIFIED
}

func (x *ExchangeType) GetPlan() PlanType {
	if x != nil {
		return x.Plan
	}
	return PlanType_PLAN_TYPE_UNSPECIFIED
}

type HandlerRequirement struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Message       *ExchangeType          `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	Cardinality   HandlerCardinality     `protobuf:"varint,2,opt,name=cardinality,proto3,enum=ar.v1.HandlerCardinality" json:"cardinality,omitempty"`
	Rationale     string                 `protobuf:"bytes,3,opt,name=rationale,proto3" json:"rationale,omitempty"` // optional but super helpful for UI
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HandlerRequirement) Reset() {
	*x = HandlerRequirement{}
	mi := &file_ar_v1_events_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HandlerRequirement) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HandlerRequirement) ProtoMessage() {}

func (x *HandlerRequirement) ProtoReflect() protoreflect.Message {
	mi := &file_ar_v1_events_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HandlerRequirement.ProtoReflect.Descriptor instead.
func (*HandlerRequirement) Descriptor() ([]byte, []int) {
	return file_ar_v1_events_proto_rawDescGZIP(), []int{1}
}

func (x *HandlerRequirement) GetMessage() *ExchangeType {
	if x != nil {
		return x.Message
	}
	return nil
}

func (x *HandlerRequirement) GetCardinality() HandlerCardinality {
	if x != nil {
		return x.Cardinality
	}
	return HandlerCardinality_HANDLER_CARDINALITY_UNSPECIFIED
}

func (x *HandlerRequirement) GetRationale() string {
	if x != nil {
		return x.Rationale
	}
	return ""
}

type ExchangeSupport struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Message       *ExchangeType          `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	Rationale     string                 `protobuf:"bytes,2,opt,name=rationale,proto3" json:"rationale,omitempty"` // optional but super helpful for UI
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExchangeSupport) Reset() {
	*x = ExchangeSupport{}
	mi := &file_ar_v1_events_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExchangeSupport) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExchangeSupport) ProtoMessage() {}

func (x *ExchangeSupport) ProtoReflect() protoreflect.Message {
	mi := &file_ar_v1_events_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExchangeSupport.ProtoReflect.Descriptor instead.
func (*ExchangeSupport) Descriptor() ([]byte, []int) {
	return file_ar_v1_events_proto_rawDescGZIP(), []int{2}
}

func (x *ExchangeSupport) GetMessage() *ExchangeType {
	if x != nil {
		return x.Message
	}
	return nil
}

func (x *ExchangeSupport) GetRationale() string {
	if x != nil {
		return x.Rationale
	}
	return ""
}

// Supported events is a list of all supported events in the current configuration
// TODO: should this be a field of ARConfig?
type SupportedExchangesMessage struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Exchanges     []*ExchangeSupport     `protobuf:"bytes,1,rep,name=exchanges,proto3" json:"exchanges,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SupportedExchangesMessage) Reset() {
	*x = SupportedExchangesMessage{}
	mi := &file_ar_v1_events_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SupportedExchangesMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SupportedExchangesMessage) ProtoMessage() {}

func (x *SupportedExchangesMessage) ProtoReflect() protoreflect.Message {
	mi := &file_ar_v1_events_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SupportedExchangesMessage.ProtoReflect.Descriptor instead.
func (*SupportedExchangesMessage) Descriptor() ([]byte, []int) {
	return file_ar_v1_events_proto_rawDescGZIP(), []int{3}
}

func (x *SupportedExchangesMessage) GetExchanges() []*ExchangeSupport {
	if x != nil {
		return x.Exchanges
	}
	return nil
}

var File_ar_v1_events_proto protoreflect.FileDescriptor

const file_ar_v1_events_proto_rawDesc = "" +
	"\n" +
	"\x12ar/v1/events.proto\x12\x05ar.v1\x1a\x1bbuf/validate/validate.proto\"\x8f\x02\n" +
	"\fExchangeType\x126\n" +
	"\acommand\x18\x01 \x01(\x0e2\x12.ar.v1.CommandTypeB\b\xbaH\x05\x82\x01\x02\x10\x01R\acommand\x120\n" +
	"\x05event\x18\x02 \x01(\x0e2\x10.ar.v1.EventTypeB\b\xbaH\x05\x82\x01\x02\x10\x01R\x05event\x12<\n" +
	"\ttelemetry\x18\x03 \x01(\x0e2\x14.ar.v1.TelemetryTypeB\b\xbaH\x05\x82\x01\x02\x10\x01R\ttelemetry\x12-\n" +
	"\x04plan\x18\x04 \x01(\x0e2\x0f.ar.v1.PlanTypeB\b\xbaH\x05\x82\x01\x02\x10\x01R\x04plan:(\xbaH%\"#\n" +
	"\acommand\n" +
	"\x05event\n" +
	"\ttelemetry\n" +
	"\x04plan\x10\x01\"\xa8\x01\n" +
	"\x12HandlerRequirement\x12-\n" +
	"\amessage\x18\x01 \x01(\v2\x13.ar.v1.ExchangeTypeR\amessage\x12E\n" +
	"\vcardinality\x18\x02 \x01(\x0e2\x19.ar.v1.HandlerCardinalityB\b\xbaH\x05\x82\x01\x02\x10\x01R\vcardinality\x12\x1c\n" +
	"\trationale\x18\x03 \x01(\tR\trationale\"^\n" +
	"\x0fExchangeSupport\x12-\n" +
	"\amessage\x18\x01 \x01(\v2\x13.ar.v1.ExchangeTypeR\amessage\x12\x1c\n" +
	"\trationale\x18\x02 \x01(\tR\trationale\"Q\n" +
	"\x19SupportedExchangesMessage\x124\n" +
	"\texchanges\x18\x01 \x03(\v2\x16.ar.v1.ExchangeSupportR\texchanges*\x8a\x03\n" +
	"\vCommandType\x12\x1c\n" +
	"\x18COMMAND_TYPE_UNSPECIFIED\x10\x00\x12\x1e\n" +
	"\x1aCOMMAND_TYPE_TASK_COMPLETE\x10\n" +
	"\x12\x1c\n" +
	"\x18COMMAND_TYPE_TASK_ASSIGN\x10\v\x12\x1a\n" +
	"\x16COMMAND_TYPE_TASK_UNDO\x10\f\x12\x1f\n" +
	"\x1bCOMMAND_TYPE_TASK_HIGHLIGHT\x10\r\x12\x1a\n" +
	"\x16COMMAND_TYPE_TASK_HELP\x10\x0e\x12!\n" +
	"\x1dCOMMAND_TYPE_ROBOT_START_STOP\x10d\x12(\n" +
	"$COMMAND_TYPE_ROBOT_TOGGLE_FREE_DRIVE\x10e\x12*\n" +
	"&COMMAND_TYPE_ROBOT_START_COLLABORATION\x10f\x12)\n" +
	"%COMMAND_TYPE_ROBOT_STOP_COLLABORATION\x10g\x12\"\n" +
	"\x1eCOMMAND_TYPE_ROBOT_ACKNOWLEDGE\x10h*\xc4\x03\n" +
	"\tEventType\x12\x1a\n" +
	"\x16EVENT_TYPE_UNSPECIFIED\x10\x00\x12\x1f\n" +
	"\x1bEVENT_TYPE_PROCESS_COMPLETE\x10\n" +
	"\x12 \n" +
	"\x1cEVENT_TYPE_SEQUENCE_COMPLETE\x10\v\x12\x1c\n" +
	"\x18EVENT_TYPE_TASK_COMPLETE\x10\f\x12%\n" +
	"!EVENT_TYPE_ROBOT_WAYPOINT_REACHED\x10d\x12\"\n" +
	"\x1dEVENT_TYPE_ROBOT_PLAN_STARTED\x10\x82\x01\x12\"\n" +
	"\x1dEVENT_TYPE_ROBOT_PLAN_CHANGED\x10\x83\x01\x12\"\n" +
	"\x1dEVENT_TYPE_ROBOT_PLAN_ABORTED\x10\x84\x01\x12$\n" +
	"\x1fEVENT_TYPE_ROBOT_PLAN_COMPLETED\x10\x85\x01\x12-\n" +
	"(EVENT_TYPE_ROBOT_WAITING_FOR_ACKNOWLEDGE\x10\x96\x01\x12&\n" +
	"!EVENT_TYPE_ROBOT_WAITING_FOR_HELP\x10\x97\x01\x12*\n" +
	"%EVENT_TYPE_ROBOT_WAITING_TASK_RELEASE\x10\x98\x01*\xbb\x01\n" +
	"\rTelemetryType\x12\x1e\n" +
	"\x1aTELEMETRY_TYPE_UNSPECIFIED\x10\x00\x12\x1c\n" +
	"\x18TELEMETRY_TYPE_ROBOT_TCP\x10d\x12%\n" +
	"!TELEMETRY_TYPE_ROBOT_JOINT_ANGLES\x10e\x12%\n" +
	"!TELEMETRY_TYPE_ROBOT_FORCE_TORQUE\x10f\x12\x1e\n" +
	"\x1aTELEMETRY_TYPE_ROBOT_STATE\x10n*\xeb\x01\n" +
	"\bPlanType\x12\x19\n" +
	"\x15PLAN_TYPE_UNSPECIFIED\x10\x00\x12\x18\n" +
	"\x14PLAN_TYPE_ROBOT_PATH\x10d\x12 \n" +
	"\x1cPLAN_TYPE_ROBOT_JOINT_ANGLES\x10e\x12\x1d\n" +
	"\x19PLAN_TYPE_ROBOT_WAYPOINTS\x10f\x12(\n" +
	"$PLAN_TYPE_ROBOT_ESTIMATED_COMPLETION\x10{\x12!\n" +
	"\x1dPLAN_TYPE_ROBOT_TASK_SEQUENCE\x10|\x12\x1c\n" +
	"\x17PLAN_TYPE_TASK_SEQUENCE\x10\xc8\x01*\xa9\x01\n" +
	"\x12HandlerCardinality\x12#\n" +
	"\x1fHANDLER_CARDINALITY_UNSPECIFIED\x10\x00\x12$\n" +
	" HANDLER_CARDINALITY_AT_LEAST_ONE\x10\x01\x12#\n" +
	"\x1fHANDLER_CARDINALITY_EXACTLY_ONE\x10\x02\x12#\n" +
	"\x1fHANDLER_CARDINALITY_AT_MOST_ONE\x10\x03B\x87\x01\n" +
	"\tcom.ar.v1B\vEventsProtoP\x01Z/github.com/cobotar/protocol/messages/ar/v1;arv1\xa2\x02\x03AXX\xaa\x02\x0eMessages.AR.V1\xca\x02\x05Ar\\V1\xe2\x02\x11Ar\\V1\\GPBMetadata\xea\x02\x06Ar::V1b\x06proto3"

var (
	file_ar_v1_events_proto_rawDescOnce sync.Once
	file_ar_v1_events_proto_rawDescData []byte
)

func file_ar_v1_events_proto_rawDescGZIP() []byte {
	file_ar_v1_events_proto_rawDescOnce.Do(func() {
		file_ar_v1_events_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_ar_v1_events_proto_rawDesc), len(file_ar_v1_events_proto_rawDesc)))
	})
	return file_ar_v1_events_proto_rawDescData
}

var file_ar_v1_events_proto_enumTypes = make([]protoimpl.EnumInfo, 5)
var file_ar_v1_events_proto_msgTypes = make([]protoimpl.MessageInfo, 4)
var file_ar_v1_events_proto_goTypes = []any{
	(CommandType)(0),                  // 0: ar.v1.CommandType
	(EventType)(0),                    // 1: ar.v1.EventType
	(TelemetryType)(0),                // 2: ar.v1.TelemetryType
	(PlanType)(0),                     // 3: ar.v1.PlanType
	(HandlerCardinality)(0),           // 4: ar.v1.HandlerCardinality
	(*ExchangeType)(nil),              // 5: ar.v1.ExchangeType
	(*HandlerRequirement)(nil),        // 6: ar.v1.HandlerRequirement
	(*ExchangeSupport)(nil),           // 7: ar.v1.ExchangeSupport
	(*SupportedExchangesMessage)(nil), // 8: ar.v1.SupportedExchangesMessage
}
var file_ar_v1_events_proto_depIdxs = []int32{
	0, // 0: ar.v1.ExchangeType.command:type_name -> ar.v1.CommandType
	1, // 1: ar.v1.ExchangeType.event:type_name -> ar.v1.EventType
	2, // 2: ar.v1.ExchangeType.telemetry:type_name -> ar.v1.TelemetryType
	3, // 3: ar.v1.ExchangeType.plan:type_name -> ar.v1.PlanType
	5, // 4: ar.v1.HandlerRequirement.message:type_name -> ar.v1.ExchangeType
	4, // 5: ar.v1.HandlerRequirement.cardinality:type_name -> ar.v1.HandlerCardinality
	5, // 6: ar.v1.ExchangeSupport.message:type_name -> ar.v1.ExchangeType
	7, // 7: ar.v1.SupportedExchangesMessage.exchanges:type_name -> ar.v1.ExchangeSupport
	8, // [8:8] is the sub-list for method output_type
	8, // [8:8] is the sub-list for method input_type
	8, // [8:8] is the sub-list for extension type_name
	8, // [8:8] is the sub-list for extension extendee
	0, // [0:8] is the sub-list for field type_name
}

func init() { file_ar_v1_events_proto_init() }
func file_ar_v1_events_proto_init() {
	if File_ar_v1_events_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_ar_v1_events_proto_rawDesc), len(file_ar_v1_events_proto_rawDesc)),
			NumEnums:      5,
			NumMessages:   4,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_ar_v1_events_proto_goTypes,
		DependencyIndexes: file_ar_v1_events_proto_depIdxs,
		EnumInfos:         file_ar_v1_events_proto_enumTypes,
		MessageInfos:      file_ar_v1_events_proto_msgTypes,
	}.Build()
	File_ar_v1_events_proto = out.File
	file_ar_v1_events_proto_goTypes = nil
	file_ar_v1_events_proto_depIdxs = nil
}
